<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minimal Tetris Game</title>
  <style>
    body {
      background: #222;
      color: #eee;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      margin: 0;
      justify-content: center;
    }
    #score {
      font-size: 1.5em;
      margin-bottom: 0.5em;
    }
    #game-container {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: center;
    }
    #tetris-grid {
      display: grid;
      grid-template-rows: repeat(20, 22px);
      grid-template-columns: repeat(10, 22px);
      background: #333;
      border: 2px solid #444;
      box-shadow: 0 0 16px #0008;
      margin-right: 1em;
    }
    .cell {
      width: 20px;
      height: 20px;
      border: 1px solid #444;
      background: #222;
      box-sizing: border-box;
    }
    .filled {
      background: #1abc9c;
    }
    .I  { background: #00ced1; }
    .O  { background: #ffe066; }
    .T  { background: #b980f0; }
    .S  { background: #66e066; }
    .Z  { background: #e06666; }
    .J  { background: #6681e0; }
    .L  { background: #ffab66; }
    #game-over {
      position: absolute;
      left: 0; right: 0;
      top: 50%;
      transform: translateY(-50%);
      color: #fff;
      font-size: 2em;
      text-align: center;
      background: rgba(30,30,30,0.95);
      padding: 1em 2em;
      border-radius: 8px;
      display: none;
      z-index: 2;
      box-shadow: 0 0 12px #0009;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="game-container">
    <div id="tetris-grid"></div>
  </div>
  <div id="game-over">Game Over<br><small>Press R to Restart</small></div>
  <script>
    // Grid size
    const ROWS = 20;
    const COLS = 10;
    // Tetromino shapes (each is a 4x4 grid)
    const TETROMINOES = {
      I: [
        [[0,1,0,0],
         [0,1,0,0],
         [0,1,0,0],
         [0,1,0,0]],
        [[0,0,0,0],
         [1,1,1,1],
         [0,0,0,0],
         [0,0,0,0]]
      ],
      O: [
        [[0,0,0,0],
         [0,1,1,0],
         [0,1,1,0],
         [0,0,0,0]]
      ],
      T: [
        [[0,0,0,0],
         [1,1,1,0],
         [0,1,0,0],
         [0,0,0,0]],
        [[0,1,0,0],
         [1,1,0,0],
         [0,1,0,0],
         [0,0,0,0]],
        [[0,1,0,0],
         [1,1,1,0],
         [0,0,0,0],
         [0,0,0,0]],
        [[0,1,0,0],
         [0,1,1,0],
         [0,1,0,0],
         [0,0,0,0]]
      ],
      S: [
        [[0,0,0,0],
         [0,1,1,0],
         [1,1,0,0],
         [0,0,0,0]],
        [[1,0,0,0],
         [1,1,0,0],
         [0,1,0,0],
         [0,0,0,0]]
      ],
      Z: [
        [[0,0,0,0],
         [1,1,0,0],
         [0,1,1,0],
         [0,0,0,0]],
        [[0,1,0,0],
         [1,1,0,0],
         [1,0,0,0],
         [0,0,0,0]]
      ],
      J: [
        [[0,0,0,0],
         [1,0,0,0],
         [1,1,1,0],
         [0,0,0,0]],
        [[0,1,1,0],
         [0,1,0,0],
         [0,1,0,0],
         [0,0,0,0]],
        [[0,0,0,0],
         [1,1,1,0],
         [0,0,1,0],
         [0,0,0,0]],
        [[0,1,0,0],
         [0,1,0,0],
         [1,1,0,0],
         [0,0,0,0]]
      ],
      L: [
        [[0,0,0,0],
         [0,0,1,0],
         [1,1,1,0],
         [0,0,0,0]],
        [[0,1,0,0],
         [0,1,0,0],
         [0,1,1,0],
         [0,0,0,0]],
        [[0,0,0,0],
         [1,1,1,0],
         [1,0,0,0],
         [0,0,0,0]],
        [[1,1,0,0],
         [0,1,0,0],
         [0,1,0,0],
         [0,0,0,0]]
      ]
    };

    // Array of the shape keys
    const SHAPE_KEYS = Object.keys(TETROMINOES);

    // The grid (20 rows x 10 cols)
    let grid = [];
    // Score
    let score = 0;
    // Current piece
    let current;
    // Falling interval
    let interval = null;
    // Game Over state
    let gameOver = false;

    function emptyRow() {
      return Array(COLS).fill('');
    }

    function createGrid() {
      grid = [];
      for(let r=0; r<ROWS; ++r)
        grid.push(emptyRow());
    }

    // Piece object
    function randomPiece() {
      const shapeKey = SHAPE_KEYS[Math.floor(Math.random()*SHAPE_KEYS.length)];
      const rotations = TETROMINOES[shapeKey];
      return {
        shapeKey,
        rotations,
        rotation: 0,
        row: 0,
        col: shapeKey === 'I' ? 3 : 3, // Center
      };
    }

    function drawGrid() {
      const gridDiv = document.getElementById('tetris-grid');
      // Remove all child nodes
      while (gridDiv.firstChild)
        gridDiv.removeChild(gridDiv.firstChild);
      for (let r = 0; r < ROWS; ++r) {
        for (let c = 0; c < COLS; ++c) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (grid[r][c]) {
            cell.classList.add('filled', grid[r][c]);
          }
          // Overlay current piece
          if (current && occupies(current, r, c)) {
            cell.classList.add('filled', current.shapeKey);
          }
          gridDiv.appendChild(cell);
        }
      }
    }

    function occupies(piece, r, c) {
      const mat = piece.rotations[piece.rotation];
      for (let i = 0; i < 4; ++i)
        for (let j = 0; j < 4; ++j)
          if (mat[i][j])
            if (piece.row + i === r && piece.col + j === c)
              return true;
      return false;
    }

    function collides(piece, newRow, newCol, newRotation) {
      const mat = piece.rotations[newRotation];
      for (let i = 0; i < 4; ++i)
        for (let j = 0; j < 4; ++j)
          if (mat[i][j]) {
            let r = newRow + i, c = newCol + j;
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS)
              return true;
            if (grid[r][c])
              return true;
          }
      return false;
    }

    function freeze() {
      const mat = current.rotations[current.rotation];
      for (let i = 0; i < 4; ++i)
        for (let j = 0; j < 4; ++j)
          if (mat[i][j]) {
            let r = current.row + i, c = current.col + j;
            if (r >= 0 && r < ROWS && c >= 0 && c < COLS)
              grid[r][c] = current.shapeKey;
          }
    }

    function clearLines() {
      let lines = 0;
      for (let r=ROWS-1; r>=0; --r) {
        if (grid[r].every(cell => cell)) {
          // Remove row
          grid.splice(r, 1);
          // Add empty row at top
          grid.unshift(emptyRow());
          ++lines;
          ++r; // Stay on same row index (since rows shift down)
        }
      }
      score += lines * 100;
    }

    function dropDown() {
      if (!move(1,0,0)) {
        freeze();
        clearLines();
        spawnNew();
      }
    }

    function move(dr, dc, drot) {
      let newRotation = (current.rotation + drot + current.rotations.length) % current.rotations.length;
      if (!collides(current, current.row + dr, current.col + dc, newRotation)) {
        current.row += dr;
        current.col += dc;
        current.rotation = newRotation;
        return true;
      }
      return false;
    }

    function spawnNew() {
      current = randomPiece();
      if (collides(current, current.row, current.col, current.rotation)) {
        endGame();
      }
    }

    function endGame() {
      clearInterval(interval);
      gameOver = true;
      document.getElementById('game-over').style.display = 'block';
    }

    function updateScore() {
      document.getElementById('score').innerText = 'Score: ' + score;
    }

    function gameLoop() {
      if (gameOver) return;
      dropDown();
      drawGrid();
      updateScore();
    }

    function onKeyDown(e) {
      if (gameOver && (e.key === 'r' || e.key === 'R')) {
        startGame();
        return;
      }
      if (gameOver) return;
      let acted = false;
      if (e.key === 'ArrowLeft') {
        acted = move(0,-1,0);
      } else if (e.key === 'ArrowRight') {
        acted = move(0,1,0);
      } else if (e.key === 'ArrowDown') {
        acted = move(1,0,0);
      } else if (e.key === 'ArrowUp') {
        acted = move(0,0,1);
      } else if (e.key === ' ' || e.key === 'Spacebar') {
        // Hard drop
        while (move(1,0,0)) {}
        dropDown();
        acted = true;
      }
      if (acted) {
        drawGrid();
        updateScore();
      }
    }

    function startGame() {
      createGrid();
      score = 0;
      gameOver = false;
      document.getElementById('game-over').style.display = 'none';
      spawnNew();
      drawGrid();
      updateScore();
      if (interval)
        clearInterval(interval);
      interval = setInterval(gameLoop, 400);
    }

    // Build grid cells
    function initGridDiv() {
      const gridDiv = document.getElementById('tetris-grid');
      gridDiv.style.width = (COLS * 22) + "px";
      gridDiv.style.height = (ROWS * 22) + "px";
    }
    initGridDiv();
    window.addEventListener('keydown', onKeyDown);
    startGame();
  </script>
</body>
</html>